#pragma once

#include <tools/format_string.h>
#include <tools/istream_tools.h>
// #include <iostream>
#include <climits>
#include <hash_map>
#include <memory>
#include <random>
// #include <asio.hpp>
// #include <stdio.h>
// #include <istream>
// #include <streambuf>
#include <iosfwd>

namespace KCore
{
    using namespace std;
    using asio::ip::tcp;

#define SPACE " "
#define END_LINE "\r\n"
#define END_HEADER "\r\n\r\n"
#define COLON ":"

    struct Header
    {
    public:
        string key;
        string value;
        virtual ~Header() = default;
        friend ostream &operator<<(ostream &out, const Header &instance);
        friend istream &operator>>(istream &in, Header &instance);
    };

#define HEADER_REGISTERY HeaderRegistery::getInstance()
    class HeaderRegistery
    {
    private:
#define CreateHeaderType function<Header()>
        map<string, CreateHeaderType> headers;

    public:
        static HeaderRegistery &getInstance()
        {
            static HeaderRegistery s_instance;
            return s_instance;
        }

        template <typename U>
        void registerHeader(string name)
        {
            headers.insert({name, [name]() -> U
                            {
                                U instance = {};
                                instance.key = name;
                                return instance;
                            }});
        }

        Header createHeader(string name)
        {
            const auto it = headers.find(name);
            if (it == headers.end())
            {
                throw runtime_error("Header Not Registerd");
                return {}; // not a derived class
            }
            auto instance = (it->second)();
            return (it->second)();
        }

        template <typename T>
        class Creator
        {
        public:
            explicit Creator(const std::string &name)
            {
                HEADER_REGISTERY.registerHeader<T>(name);
            }
        };
    };

#define REGISTER_HEADER(header_type) \
    HeaderRegistery::Creator<header_type> s_##header_type##Creator(#header_type);

    struct RequestMethod
    {
        string value;

        friend ostream &operator<<(ostream &out, const RequestMethod &instance)
        {
            return out << instance.value;
        }

        friend istream &operator>>(std::istream &in, RequestMethod &instance)
        {
            IStreamSplitter::readUntil(in, instance.value, SPACE);
            return in;
        }
    };
#define REQUEST_METHOD_GET \
    (RequestMethod) { "GET" }
#define REQUEST_METHOD_POST \
    (RequestMethod) { "POST" }
#define REQUEST_METHOD_PUT \
    (RequestMethod) { "PUT" }
#define REQUEST_METHOD_HEAD \
    (RequestMethod) { "HEAD" }
#define REQUEST_METHOD_DELETE \
    (RequestMethod) { "DELETE" }
#define REQUEST_METHOD_PATCH \
    (RequestMethod) { "PATCH" }
#define REQUEST_METHOD_OPTIONS \
    (RequestMethod) { "OPTIONS" }

    struct RequestPath
    {
        string value;

        friend ostream &operator<<(ostream &out, const RequestPath &instance)
        {
            return out << instance.value;
        }

        friend istream &operator>>(istream &in, RequestPath &instance)
        {
            IStreamSplitter::readUntil(in, instance.value, SPACE);
            return in;
        }
    };

    struct HttpVersion
    {
        string value;

        friend ostream &operator<<(ostream &out, const HttpVersion &instance)
        {
            return out << instance.value;
        }

        friend istream &operator>>(istream &in, HttpVersion &instance)
        {
            IStreamSplitter::readUntil(in, instance.value, SPACE);
            return in;
        }
    };
#define HTTP_VERSION_1_1 \
    (HttpVersion) { "HTTP/1.1" }

    struct Accept
    {
        string value;
        string name = string("Accept");

        friend ostream &operator<<(ostream &out, const Accept &instance)
        {
            return out << instance.name << COLON << instance.value;
        }

        friend istream &operator>>(istream &in, Accept &instance)
        {
            return in;
        }
    };
#define ACCEPT_PLAIN_TEXT \
    (Accept) { "text/plain" }
#define ACCEPT_HTML \
    (Accept) { "text/html" }
#define ACCEPT_JSON \
    (Accept) { "application/json" }

    struct AcceptCharset
    {
        string value;
        friend ostream &operator<<(ostream &out, const AcceptCharset &instance)
        {
            return out << "Accept-Charset:" << instance.value;
        }
    };
#define ACCEPT_CHARSET_ASCII \
    (AcceptCharset) { "acsii" }
#define ACCEPT_CHARSET_WINdows_1252 \
    (AcceptCharset) { "windows-1252" }
#define ACCEPT_CHARSET_ISO_8859_1 \
    (AcceptCharset) { "iso-8859-1" }
#define ACCEPT_CHARSET_utf_8 \
    (AcceptCharset) { "utf-8" }

    struct AcceptEncoding
    {
        string value;
        friend ostream &operator<<(ostream &out, const AcceptEncoding &instance)
        {
            return out << "Accept-Encoding:" << instance.value;
        }
    };
#define ACCEPT_ENCODING_GZIP \
    (AcceptEncoding) { "gzip" }
#define ACCEPT_ENCODING_COMPRESS \
    (AcceptEncoding) { "compress" }
#define ACCEPT_ENCODING_DEFLATGE \
    (AcceptEncoding) { "deflate" }
#define ACCEPT_ENCODING_BR \
    (AcceptEncoding) { "br" }
#define ACCEPT_ENCODING_IDENTITY \
    (AcceptEncoding) { "identity" }
#define ACCEPT_ENCODING_ALL \
    (AcceptEncoding) { "*" }

    struct AcceptLanguage
    {
        string value;
        friend ostream &operator<<(ostream &out, const AcceptLanguage &instance)
        {
            return out << "Accept-Language:" << instance.value;
        }
    };
#define ACCEPT_LANGAGE_EN \
    (AcceptLanguage) { "en" }
#define ACCEPT_LANGAGE_FA \
    (AcceptLanguage) { "fa" }

    struct AcceptRanges
    {
        string value;
        friend ostream &operator<<(ostream &out, const AcceptRanges &instance)
        {
            return out << "Accept-Ranges:" << instance.value;
        }
    };
#define ACCEPT_RANGES_BYTES \
    (AcceptRanges) { "bytes" }
#define ACCEPT_RANGES_NONE \
    (AcceptRanges) { "none" }

    struct Authorization
    {
        string value;
        friend ostream &operator<<(ostream &out, const Authorization &instance)
        {
            return out << "Authorization:" << instance.value;
        }
    };

    struct Connection
    {
        string value;
        friend ostream &operator<<(ostream &out, const Connection &instance)
        {
            return out << "Connection:" << instance.value;
        }
    };
#define CONNECTION_CLOSE \
    (Connection) { "close" }
#define CONNECTION_KEEP_ALIVE \
    (Connection) { "keep-alive" }

    struct ContentEncoding
    {
        string value;
        friend ostream &operator<<(ostream &out, const ContentEncoding &instance)
        {
            return out << "Content-Encoding:" << instance.value;
        }
    };
#define CONTENT_ENCODING_GZIP \
    (ContentEncoding) { "gzip" }
#define CONTENT_ENCODING_COMPRESS \
    (ContentEncoding) { "compress" }
#define CONTENT_ENCODING_DEFLATGE \
    (ContentEncoding) { "deflate" }
#define CONTENT_ENCODING_BR \
    (ContentEncoding) { "br" }
#define CONTENT_ENCODING_IDENTITY \
    (ContentEncoding) { "identity" }

    struct ContentLanguage
    {
        string value;
        friend ostream &operator<<(ostream &out, const ContentLanguage &instance)
        {
            return out << "Content-Language:" << instance.value;
        }
    };
#define CONTENT_LANGAGE_EN \
    (ContentLanguage) { "en" }
#define CONTENT_LANGAGE_FA \
    (ContentLanguage) { "en" }

    struct ContentLength
    {
        ulong value;
        friend ostream &operator<<(ostream &out, const ContentLength &instance)
        {
            return out << "Content-Length:" << instance.value;
        }
    };

    struct ContentLocation
    {
        ulong value;
        friend ostream &operator<<(ostream &out, const ContentLocation &instance)
        {
            return out << "Content-Location:" << instance.value;
        }
    };

    struct ContentMD5
    {
        ulong value;
        friend ostream &operator<<(ostream &out, const ContentMD5 &instance)
        {
            return out << "Content-MD5:" << instance.value;
        }
    };

    struct ContentLenght
    {
        ulong value;

        friend ostream &operator<<(ostream &out, const ContentLenght &instance)
        {
            return out << "Content-Length:" << instance.value;
        }
    };

    struct ContentRange
    {
        ulong start;
        ulong end;
        ulong total;

        friend ostream &operator<<(ostream &out, const ContentRange &instance)
        {
            return out << "Content-Range:" << instance.start << '-' << instance.end << "/" << instance.total;
        }
    };

    struct ContentType
    {
        ulong value;
        friend ostream &operator<<(ostream &out, const ContentType &instance)
        {
            return out << "Content-MD5:" << instance.value;
        }
    };
#define CONTENT_TYPE_PLAIN_TEXT \
    (ContentType) { "text/plain" }
#define CONTENT_TYPE_HTML \
    (ContentType) { "text/html" }
#define CONTENT_TYPE_JSON \
    (ContentType) { "application/json" }

    struct UserAgent
    {
        ulong value;

        friend ostream &operator<<(ostream &out, const UserAgent &instance)
        {
            return out << "User-Agent:" << instance.value;
        }
    };
#define USER_AGENT_CHROME_WINDOWS \
    (UserAgent) { "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36" }
#define USER_AGENT_CHROME_MACOS \
    (UserAgent) { "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36" }
#define USER_AGENT_CHROME_LINUX \
    (UserAgent) { "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36" }
#define USER_AGENT_FIREFOX_WINDOWS \
    (UserAgent) { "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0" }
#define USER_AGENT_FIREFOX_MACOS \
    (UserAgent) { "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:90.0) Gecko/20100101 Firefox/90.0" }
#define USER_AGENT_FIREFOX_LINUX \
    (UserAgent) { "Mozilla/5.0 (X11; Linux x86_64; rv:90.0) Gecko/20100101 Firefox/90.0" }

    struct Server : Header
    {
    public:

        friend istream &operator>>(istream &in, Server &instance)
        {
            LOG_TRACE("Reading Server 1");
            IStreamSplitter::readUntil(in, instance.value, END_LINE);
            return in;
        }

        friend istream &operator>>(istream &in, Header &instance)
        {
            LOG_TRACE("Reading Server 2");
            IStreamSplitter::readUntil(in, instance.value, END_LINE);
            LOG(instance.value);
            return in;
        }
    };
    REGISTER_HEADER(Server);

    struct Address
    {
        string host;
        string path;

        friend ostream &operator<<(ostream &out, const Address &instance)
        {
            return out << instance.host << "/" << instance.path;
        }
    };

    struct RequestDefinition
    {
        RequestMethod method;
        RequestPath requestPath;
        HttpVersion httpVersion;

        friend ostream &operator<<(ostream &out, const RequestDefinition &instance)
        {
            return out << instance.method << SPACE
                       << instance.requestPath << SPACE
                       << instance.httpVersion << END_LINE;
        }

        friend istream &operator>>(istream &in, RequestDefinition &instance)
        {
            instance = RequestDefinition();
            in >> instance.method >> instance.requestPath >> instance.httpVersion;
            return in;
        }
    };

    struct ServerResponseCode
    {
    private:
    public:
        uint code;
        string definition;

        friend istream &operator>>(istream &in, ServerResponseCode &instance)
        {
            string stringCode;
            IStreamSplitter::readUntil(in, stringCode, SPACE);
            instance.code = stoul(stringCode);
            IStreamSplitter::readUntil(in, instance.definition, END_HEADER);
            return in;
        }
    };

    struct ResponseDeffinition
    {
        HttpVersion httpVersion;
        ServerResponseCode responseCode;

        friend istream &operator>>(istream &in, ResponseDeffinition &instance)
        {
            in >> instance.httpVersion >> instance.responseCode;
            return in;
        }
    };

    struct Boundary
    {
        string value;
        friend ostream &operator<<(ostream &out, const Boundary &instance)
        {
            return out << instance.value;
        }
    };
    static default_random_engine RANDOM_GENERATOR;
    inline Boundary makeBoundary()
    {
        uniform_int_distribution<ulong> distribution(0, ULONG_MAX);
        ulong result = distribution(RANDOM_GENERATOR);
        return (Boundary){"--boundary--" + to_string(result)};
    }

    struct HttpRequest
    {
        RequestDefinition requestDefinition;
        Address address;
        Accept accept;
        Connection connection;
        map<string, string> formData;

        friend ostream &operator<<(ostream &out, const HttpRequest &instance)
        {
            return out << instance.requestDefinition
                       << "Host: " << instance.address.host << END_LINE
                       << instance.accept << END_LINE << instance.connection << END_HEADER;
        }
    };

    struct HttpResponse
    {
    public:
        ResponseDeffinition requestDefinition;
        Server server;

        friend istream &operator>>(istream &in, HttpResponse &instance)
        {
            in >> instance.requestDefinition;
            string h1;
            IStreamSplitter::readUntil(in, h1, COLON);
            instance.server = HEADER_REGISTERY.createHeader(h1);
            in >> h;
            return in;
        }
    };
}